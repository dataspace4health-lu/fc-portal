/* tslint:disable */
/* eslint-disable */
/**
 * GAIA-X Federated Catalogue
 * This is the REST API of the Gaia-X catalogue.
 *
 * The version of the OpenAPI document: 2.0.0-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * JSON object containing query with parameters and annotations
 * @export
 * @interface AnnotatedStatement
 */
export interface AnnotatedStatement {
    /**
     * 
     * @type {string}
     * @memberof AnnotatedStatement
     */
    'statement': string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AnnotatedStatement
     */
    'parameters'?: { [key: string]: object; };
    /**
     * 
     * @type {Set<string>}
     * @memberof AnnotatedStatement
     */
    'servers'?: Set<string>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AnnotatedStatement
     */
    'annotations'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface OntologySchema
 */
export interface OntologySchema {
    /**
     * SchemaIds of ontologies, defining the terms of a schema
     * @type {Array<string>}
     * @memberof OntologySchema
     */
    'ontologies'?: Array<string>;
    /**
     * SchemaIds of shapes (SHACL Shapes Constraint Language) used to validate instances against the schema.
     * @type {Array<string>}
     * @memberof OntologySchema
     */
    'shapes'?: Array<string>;
    /**
     * SchemaIds of controlled vocabularies used in the schema
     * @type {Array<string>}
     * @memberof OntologySchema
     */
    'vocabularies'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Participant
 */
export interface Participant {
    /**
     * Global ID of the participant
     * @type {string}
     * @memberof Participant
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'publicKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'selfDescription'?: string;
}
/**
 * 
 * @export
 * @interface Participants
 */
export interface Participants {
    /**
     * 
     * @type {number}
     * @memberof Participants
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<Participant>}
     * @memberof Participants
     */
    'items'?: Array<Participant>;
}
/**
 * 
 * @export
 * @interface Results
 */
export interface Results {
    /**
     * 
     * @type {number}
     * @memberof Results
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof Results
     */
    'items'?: Array<{ [key: string]: object; }>;
}
/**
 * 
 * @export
 * @interface SelfDescription
 */
export interface SelfDescription {
    /**
     * 
     * @type {string}
     * @memberof SelfDescription
     */
    'sdHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SelfDescription
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SelfDescription
     */
    'status'?: SelfDescriptionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SelfDescription
     */
    'issuer'?: string;
    /**
     * The credentialSubjects of the parties that validated (parts of) the Self-Description
     * @type {Array<string>}
     * @memberof SelfDescription
     */
    'validatorDids'?: Array<string>;
    /**
     * The time stamp (ISO8601) when the SD was uploaded.
     * @type {string}
     * @memberof SelfDescription
     */
    'uploadDatetime'?: string;
    /**
     * The last time stamp (ISO8601) the status changed (for this Catalogue)
     * @type {string}
     * @memberof SelfDescription
     */
    'statusDatetime'?: string;
}

export const SelfDescriptionStatusEnum = {
    Active: 'active',
    Eol: 'eol',
    Deprecated: 'deprecated',
    Revoked: 'revoked'
} as const;

export type SelfDescriptionStatusEnum = typeof SelfDescriptionStatusEnum[keyof typeof SelfDescriptionStatusEnum];

/**
 * 
 * @export
 * @interface SelfDescriptionResult
 */
export interface SelfDescriptionResult {
    /**
     * 
     * @type {SelfDescription}
     * @memberof SelfDescriptionResult
     */
    'meta'?: SelfDescription;
    /**
     * 
     * @type {string}
     * @memberof SelfDescriptionResult
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface SelfDescriptions
 */
export interface SelfDescriptions {
    /**
     * 
     * @type {number}
     * @memberof SelfDescriptions
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<SelfDescriptionResult>}
     * @memberof SelfDescriptions
     */
    'items'?: Array<SelfDescriptionResult>;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'creationDatetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'status'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Session
     */
    'roleIds'?: Array<string>;
}
/**
 * JSON object to send queries. Use \"application/json\" for openCypher queries. A Catalogue may also support the other content types depending on its supported query languages but only \"application/json\" is mandatory.
 * @export
 * @interface Statement
 */
export interface Statement {
    /**
     * 
     * @type {string}
     * @memberof Statement
     */
    'statement': string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Statement
     */
    'parameters'?: { [key: string]: object; };
}
/**
 * User profile
 * @export
 * @interface User
 */
export interface User {
    /**
     * Global ID of the associated participant
     * @type {string}
     * @memberof User
     */
    'participantId': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'roleIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * Global ID of the associated participant
     * @type {string}
     * @memberof UserProfile
     */
    'participantId': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserProfile
     */
    'roleIds'?: Array<string>;
    /**
     * Internal catalogue user id
     * @type {string}
     * @memberof UserProfile
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface UserProfiles
 */
export interface UserProfiles {
    /**
     * 
     * @type {number}
     * @memberof UserProfiles
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<UserProfile>}
     * @memberof UserProfiles
     */
    'items'?: Array<UserProfile>;
}
/**
 * 
 * @export
 * @interface VerificationResult
 */
export interface VerificationResult {
    /**
     * 
     * @type {string}
     * @memberof VerificationResult
     */
    'verificationTimestamp': string;
    /**
     * Lifecycle-state an SD would get, if it would be added to the catalogue.
     * @type {string}
     * @memberof VerificationResult
     */
    'lifecycleStatus': string;
    /**
     * ID of the issues Self-Description, if available.
     * @type {string}
     * @memberof VerificationResult
     */
    'issuer': string;
    /**
     * 
     * @type {string}
     * @memberof VerificationResult
     */
    'issuedDateTime': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VerificationResult
     */
    'validatorDids': Array<string>;
}

/**
 * ParticipantsApi - axios parameter creator
 * @export
 */
export const ParticipantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a new participant in the catalogue
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addParticipant: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addParticipant', 'body', body)
            const localVarPath = `/participants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a participant in the catalogue
         * @param {string} participantId The participant to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParticipant: async (participantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('deleteParticipant', 'participantId', participantId)
            const localVarPath = `/participants/{participantId}`
                .replace(`{${"participantId"}}`, encodeURIComponent(String(participantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the registered participant
         * @param {string} participantId The participantId to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipant: async (participantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('getParticipant', 'participantId', participantId)
            const localVarPath = `/participants/{participantId}`
                .replace(`{${"participantId"}}`, encodeURIComponent(String(participantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users of the registered participant
         * @param {string} participantId The participant Id
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipantUsers: async (participantId: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('getParticipantUsers', 'participantId', participantId)
            const localVarPath = `/participants/{participantId}/users`
                .replace(`{${"participantId"}}`, encodeURIComponent(String(participantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the registered participants
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipants: async (offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/participants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a participant in the catalogue
         * @param {string} participantId The participant to update.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParticipant: async (participantId: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('updateParticipant', 'participantId', participantId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateParticipant', 'body', body)
            const localVarPath = `/participants/{participantId}`
                .replace(`{${"participantId"}}`, encodeURIComponent(String(participantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParticipantsApi - functional programming interface
 * @export
 */
export const ParticipantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParticipantsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register a new participant in the catalogue
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addParticipant(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addParticipant(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantsApi.addParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a participant in the catalogue
         * @param {string} participantId The participant to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteParticipant(participantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteParticipant(participantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantsApi.deleteParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the registered participant
         * @param {string} participantId The participantId to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParticipant(participantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParticipant(participantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantsApi.getParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users of the registered participant
         * @param {string} participantId The participant Id
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParticipantUsers(participantId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfiles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParticipantUsers(participantId, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantsApi.getParticipantUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the registered participants
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParticipants(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participants>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParticipants(offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantsApi.getParticipants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a participant in the catalogue
         * @param {string} participantId The participant to update.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateParticipant(participantId: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateParticipant(participantId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantsApi.updateParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ParticipantsApi - factory interface
 * @export
 */
export const ParticipantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParticipantsApiFp(configuration)
    return {
        /**
         * 
         * @summary Register a new participant in the catalogue
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addParticipant(body: string, options?: RawAxiosRequestConfig): AxiosPromise<Participant> {
            return localVarFp.addParticipant(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a participant in the catalogue
         * @param {string} participantId The participant to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParticipant(participantId: string, options?: RawAxiosRequestConfig): AxiosPromise<Participant> {
            return localVarFp.deleteParticipant(participantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the registered participant
         * @param {string} participantId The participantId to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipant(participantId: string, options?: RawAxiosRequestConfig): AxiosPromise<Participant> {
            return localVarFp.getParticipant(participantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users of the registered participant
         * @param {string} participantId The participant Id
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipantUsers(participantId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserProfiles> {
            return localVarFp.getParticipantUsers(participantId, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the registered participants
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipants(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Participants> {
            return localVarFp.getParticipants(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a participant in the catalogue
         * @param {string} participantId The participant to update.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParticipant(participantId: string, body: string, options?: RawAxiosRequestConfig): AxiosPromise<Participant> {
            return localVarFp.updateParticipant(participantId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParticipantsApi - object-oriented interface
 * @export
 * @class ParticipantsApi
 * @extends {BaseAPI}
 */
export class ParticipantsApi extends BaseAPI {
    /**
     * 
     * @summary Register a new participant in the catalogue
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantsApi
     */
    public addParticipant(body: string, options?: RawAxiosRequestConfig) {
        return ParticipantsApiFp(this.configuration).addParticipant(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a participant in the catalogue
     * @param {string} participantId The participant to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantsApi
     */
    public deleteParticipant(participantId: string, options?: RawAxiosRequestConfig) {
        return ParticipantsApiFp(this.configuration).deleteParticipant(participantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the registered participant
     * @param {string} participantId The participantId to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantsApi
     */
    public getParticipant(participantId: string, options?: RawAxiosRequestConfig) {
        return ParticipantsApiFp(this.configuration).getParticipant(participantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users of the registered participant
     * @param {string} participantId The participant Id
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantsApi
     */
    public getParticipantUsers(participantId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ParticipantsApiFp(this.configuration).getParticipantUsers(participantId, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the registered participants
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantsApi
     */
    public getParticipants(offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ParticipantsApiFp(this.configuration).getParticipants(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a participant in the catalogue
     * @param {string} participantId The participant to update.
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantsApi
     */
    public updateParticipant(participantId: string, body: string, options?: RawAxiosRequestConfig) {
        return ParticipantsApiFp(this.configuration).updateParticipant(participantId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send a query to the Catalogue
         * @param {QueryQueryLanguageEnum} [queryLanguage] 
         * @param {number} [timeout] 
         * @param {boolean} [withTotalCount] 
         * @param {Statement} [statement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query: async (queryLanguage?: QueryQueryLanguageEnum, timeout?: number, withTotalCount?: boolean, statement?: Statement, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (queryLanguage !== undefined) {
                localVarQueryParameter['queryLanguage'] = queryLanguage;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (withTotalCount !== undefined) {
                localVarQueryParameter['withTotalCount'] = withTotalCount;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an HTML website to send openCypher queries to the Catalogue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querywebsite: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run distributed search query in the Catalogue
         * @param {AnnotatedStatement} [annotatedStatement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (annotatedStatement?: AnnotatedStatement, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/query/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotatedStatement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Send a query to the Catalogue
         * @param {QueryQueryLanguageEnum} [queryLanguage] 
         * @param {number} [timeout] 
         * @param {boolean} [withTotalCount] 
         * @param {Statement} [statement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async query(queryLanguage?: QueryQueryLanguageEnum, timeout?: number, withTotalCount?: boolean, statement?: Statement, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Results>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.query(queryLanguage, timeout, withTotalCount, statement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueryApi.query']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an HTML website to send openCypher queries to the Catalogue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async querywebsite(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.querywebsite(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueryApi.querywebsite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Run distributed search query in the Catalogue
         * @param {AnnotatedStatement} [annotatedStatement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(annotatedStatement?: AnnotatedStatement, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Results>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(annotatedStatement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueryApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * 
         * @summary Send a query to the Catalogue
         * @param {QueryQueryLanguageEnum} [queryLanguage] 
         * @param {number} [timeout] 
         * @param {boolean} [withTotalCount] 
         * @param {Statement} [statement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query(queryLanguage?: QueryQueryLanguageEnum, timeout?: number, withTotalCount?: boolean, statement?: Statement, options?: RawAxiosRequestConfig): AxiosPromise<Results> {
            return localVarFp.query(queryLanguage, timeout, withTotalCount, statement, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an HTML website to send openCypher queries to the Catalogue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querywebsite(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.querywebsite(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run distributed search query in the Catalogue
         * @param {AnnotatedStatement} [annotatedStatement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(annotatedStatement?: AnnotatedStatement, options?: RawAxiosRequestConfig): AxiosPromise<Results> {
            return localVarFp.search(annotatedStatement, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * 
     * @summary Send a query to the Catalogue
     * @param {QueryQueryLanguageEnum} [queryLanguage] 
     * @param {number} [timeout] 
     * @param {boolean} [withTotalCount] 
     * @param {Statement} [statement] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public query(queryLanguage?: QueryQueryLanguageEnum, timeout?: number, withTotalCount?: boolean, statement?: Statement, options?: RawAxiosRequestConfig) {
        return QueryApiFp(this.configuration).query(queryLanguage, timeout, withTotalCount, statement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an HTML website to send openCypher queries to the Catalogue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public querywebsite(options?: RawAxiosRequestConfig) {
        return QueryApiFp(this.configuration).querywebsite(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run distributed search query in the Catalogue
     * @param {AnnotatedStatement} [annotatedStatement] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public search(annotatedStatement?: AnnotatedStatement, options?: RawAxiosRequestConfig) {
        return QueryApiFp(this.configuration).search(annotatedStatement, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const QueryQueryLanguageEnum = {
    Opencypher: 'OPENCYPHER',
    Sparql: 'SPARQL',
    Graphql: 'GRAPHQL'
} as const;
export type QueryQueryLanguageEnum = typeof QueryQueryLanguageEnum[keyof typeof QueryQueryLanguageEnum];


/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all registered roles in the catalogue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all registered roles in the catalogue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getAllRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all registered roles in the catalogue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getAllRoles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * 
     * @summary Get all registered roles in the catalogue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getAllRoles(options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getAllRoles(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchemasApi - axios parameter creator
 * @export
 */
export const SchemasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint accepts either an ontology (OWL file), shape (SHACL file) or controlled vocabulary (SKOS file), which is added to the schemas of the catalogue.
         * @summary Add a new Schema to the catalogue.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSchema: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addSchema', 'body', body)
            const localVarPath = `/schemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/rdf+xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Schema
         * @param {string} schemaId Identifier of the Schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchema: async (schemaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('deleteSchema', 'schemaId', schemaId)
            const localVarPath = `/schemas/{schemaId}`
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest schema for a given type. If no term is specified, then the composite schema is returned.
         * @param {string} type Type of the schema.
         * @param {string} [term] The URI of the term of the requested Self-Description schema e.g. &#x60;http://w3id.org/gaia-x/service#ServiceOffering&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestSchema: async (type: string, term?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getLatestSchema', 'type', type)
            const localVarPath = `/schemas/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific schema.
         * @param {string} schemaId Identifier of the Schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema: async (schemaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('getSchema', 'schemaId', schemaId)
            const localVarPath = `/schemas/{schemaId}`
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The schema identifiers, returned by this endpoint can be used to download the schema files.
         * @summary Get the full list of ontologies, shapes and vocabularies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemas: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace a schema. This is only allowed for ontologies with the same IRI.
         * @param {string} schemaId Identifier of the Schema.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchema: async (schemaId: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('updateSchema', 'schemaId', schemaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateSchema', 'body', body)
            const localVarPath = `/schemas/{schemaId}`
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/rdf+xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemasApi - functional programming interface
 * @export
 */
export const SchemasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemasApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint accepts either an ontology (OWL file), shape (SHACL file) or controlled vocabulary (SKOS file), which is added to the schemas of the catalogue.
         * @summary Add a new Schema to the catalogue.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSchema(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSchema(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.addSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Schema
         * @param {string} schemaId Identifier of the Schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSchema(schemaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSchema(schemaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.deleteSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the latest schema for a given type. If no term is specified, then the composite schema is returned.
         * @param {string} type Type of the schema.
         * @param {string} [term] The URI of the term of the requested Self-Description schema e.g. &#x60;http://w3id.org/gaia-x/service#ServiceOffering&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestSchema(type: string, term?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestSchema(type, term, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.getLatestSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific schema.
         * @param {string} schemaId Identifier of the Schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchema(schemaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchema(schemaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.getSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The schema identifiers, returned by this endpoint can be used to download the schema files.
         * @summary Get the full list of ontologies, shapes and vocabularies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchemas(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OntologySchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchemas(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.getSchemas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Replace a schema. This is only allowed for ontologies with the same IRI.
         * @param {string} schemaId Identifier of the Schema.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchema(schemaId: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchema(schemaId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.updateSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchemasApi - factory interface
 * @export
 */
export const SchemasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemasApiFp(configuration)
    return {
        /**
         * This endpoint accepts either an ontology (OWL file), shape (SHACL file) or controlled vocabulary (SKOS file), which is added to the schemas of the catalogue.
         * @summary Add a new Schema to the catalogue.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSchema(body: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addSchema(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Schema
         * @param {string} schemaId Identifier of the Schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchema(schemaId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSchema(schemaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest schema for a given type. If no term is specified, then the composite schema is returned.
         * @param {string} type Type of the schema.
         * @param {string} [term] The URI of the term of the requested Self-Description schema e.g. &#x60;http://w3id.org/gaia-x/service#ServiceOffering&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestSchema(type: string, term?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getLatestSchema(type, term, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific schema.
         * @param {string} schemaId Identifier of the Schema.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(schemaId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getSchema(schemaId, options).then((request) => request(axios, basePath));
        },
        /**
         * The schema identifiers, returned by this endpoint can be used to download the schema files.
         * @summary Get the full list of ontologies, shapes and vocabularies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemas(options?: RawAxiosRequestConfig): AxiosPromise<OntologySchema> {
            return localVarFp.getSchemas(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace a schema. This is only allowed for ontologies with the same IRI.
         * @param {string} schemaId Identifier of the Schema.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchema(schemaId: string, body: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateSchema(schemaId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemasApi - object-oriented interface
 * @export
 * @class SchemasApi
 * @extends {BaseAPI}
 */
export class SchemasApi extends BaseAPI {
    /**
     * This endpoint accepts either an ontology (OWL file), shape (SHACL file) or controlled vocabulary (SKOS file), which is added to the schemas of the catalogue.
     * @summary Add a new Schema to the catalogue.
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public addSchema(body: string, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).addSchema(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Schema
     * @param {string} schemaId Identifier of the Schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public deleteSchema(schemaId: string, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).deleteSchema(schemaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest schema for a given type. If no term is specified, then the composite schema is returned.
     * @param {string} type Type of the schema.
     * @param {string} [term] The URI of the term of the requested Self-Description schema e.g. &#x60;http://w3id.org/gaia-x/service#ServiceOffering&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public getLatestSchema(type: string, term?: string, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).getLatestSchema(type, term, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific schema.
     * @param {string} schemaId Identifier of the Schema.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public getSchema(schemaId: string, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).getSchema(schemaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The schema identifiers, returned by this endpoint can be used to download the schema files.
     * @summary Get the full list of ontologies, shapes and vocabularies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public getSchemas(options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).getSchemas(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replace a schema. This is only allowed for ontologies with the same IRI.
     * @param {string} schemaId Identifier of the Schema.
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public updateSchema(schemaId: string, body: string, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).updateSchema(schemaId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SelfDescriptionsApi - axios parameter creator
 * @export
 */
export const SelfDescriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new Service-Offering, Participant or Resource SelfDescription to the catalogue
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSelfDescription: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addSelfDescription', 'body', body)
            const localVarPath = `/self-descriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Completely delete a self-description
         * @param {string} selfDescriptionHash Hash of the SelfDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSelfDescription: async (selfDescriptionHash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selfDescriptionHash' is not null or undefined
            assertParamExists('deleteSelfDescription', 'selfDescriptionHash', selfDescriptionHash)
            const localVarPath = `/self-descriptions/{self_description_hash}`
                .replace(`{${"self_description_hash"}}`, encodeURIComponent(String(selfDescriptionHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Self-Description
         * @summary Read a Self-Description by its hash. This returns the content of the self-description.
         * @param {string} selfDescriptionHash Hash of the SelfDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSelfDescriptionByHash: async (selfDescriptionHash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selfDescriptionHash' is not null or undefined
            assertParamExists('readSelfDescriptionByHash', 'selfDescriptionHash', selfDescriptionHash)
            const localVarPath = `/self-descriptions/{self_description_hash}`
                .replace(`{${"self_description_hash"}}`, encodeURIComponent(String(selfDescriptionHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of metadata of Self-Descriptions in the Catalogue
         * @param {string} [uploadTimerange] Filter for the time range when the Self-Description was uploaded to the catalogue. The time range has to be specified as start time and end time as ISO8601 timestamp separated by a &#x60;/&#x60;.
         * @param {string} [statusTimerange] Filter for the time range when the status of the Self-Description was last changed in the catalogue. The time range has to be specified as start time and end time as ISO8601 timestamp separated by a &#x60;/&#x60;.
         * @param {Array<string>} [issuers] Filter for the issuer of the Self-Description. This is the unique ID of the Participant that has prepared the Self-Description.
         * @param {Array<string>} [validators] Filter for a validator of the Self-Description. This is the unique ID of the Participant that validated (part of) the Self-Description.
         * @param {Array<ReadSelfDescriptionsStatusesEnum>} [statuses] Filter for the status of the Self-Description.
         * @param {Array<string>} [ids] Filter for a id/credentialSubject of the Self-Description.
         * @param {Array<string>} [hashes] Filter for a hash of the Self-Description.
         * @param {boolean} [withMeta] To add Self-Description Metadata to response or not.
         * @param {boolean} [withContent] To add Self-Description Content to response or not.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSelfDescriptions: async (uploadTimerange?: string, statusTimerange?: string, issuers?: Array<string>, validators?: Array<string>, statuses?: Array<ReadSelfDescriptionsStatusesEnum>, ids?: Array<string>, hashes?: Array<string>, withMeta?: boolean, withContent?: boolean, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/self-descriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (uploadTimerange !== undefined) {
                localVarQueryParameter['uploadTimerange'] = uploadTimerange;
            }

            if (statusTimerange !== undefined) {
                localVarQueryParameter['statusTimerange'] = statusTimerange;
            }

            if (issuers) {
                localVarQueryParameter['issuers'] = issuers;
            }

            if (validators) {
                localVarQueryParameter['validators'] = validators;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (hashes) {
                localVarQueryParameter['hashes'] = hashes;
            }

            if (withMeta !== undefined) {
                localVarQueryParameter['withMeta'] = withMeta;
            }

            if (withContent !== undefined) {
                localVarQueryParameter['withContent'] = withContent;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the lifecycle state of a SelfDescription to revoked.
         * @param {string} selfDescriptionHash Hash of the SelfDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSelfDescription: async (selfDescriptionHash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selfDescriptionHash' is not null or undefined
            assertParamExists('updateSelfDescription', 'selfDescriptionHash', selfDescriptionHash)
            const localVarPath = `/self-descriptions/{self_description_hash}/revoke`
                .replace(`{${"self_description_hash"}}`, encodeURIComponent(String(selfDescriptionHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SelfDescriptionsApi - functional programming interface
 * @export
 */
export const SelfDescriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SelfDescriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new Service-Offering, Participant or Resource SelfDescription to the catalogue
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSelfDescription(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelfDescription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSelfDescription(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SelfDescriptionsApi.addSelfDescription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Completely delete a self-description
         * @param {string} selfDescriptionHash Hash of the SelfDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSelfDescription(selfDescriptionHash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSelfDescription(selfDescriptionHash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SelfDescriptionsApi.deleteSelfDescription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single Self-Description
         * @summary Read a Self-Description by its hash. This returns the content of the self-description.
         * @param {string} selfDescriptionHash Hash of the SelfDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSelfDescriptionByHash(selfDescriptionHash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSelfDescriptionByHash(selfDescriptionHash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SelfDescriptionsApi.readSelfDescriptionByHash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the list of metadata of Self-Descriptions in the Catalogue
         * @param {string} [uploadTimerange] Filter for the time range when the Self-Description was uploaded to the catalogue. The time range has to be specified as start time and end time as ISO8601 timestamp separated by a &#x60;/&#x60;.
         * @param {string} [statusTimerange] Filter for the time range when the status of the Self-Description was last changed in the catalogue. The time range has to be specified as start time and end time as ISO8601 timestamp separated by a &#x60;/&#x60;.
         * @param {Array<string>} [issuers] Filter for the issuer of the Self-Description. This is the unique ID of the Participant that has prepared the Self-Description.
         * @param {Array<string>} [validators] Filter for a validator of the Self-Description. This is the unique ID of the Participant that validated (part of) the Self-Description.
         * @param {Array<ReadSelfDescriptionsStatusesEnum>} [statuses] Filter for the status of the Self-Description.
         * @param {Array<string>} [ids] Filter for a id/credentialSubject of the Self-Description.
         * @param {Array<string>} [hashes] Filter for a hash of the Self-Description.
         * @param {boolean} [withMeta] To add Self-Description Metadata to response or not.
         * @param {boolean} [withContent] To add Self-Description Content to response or not.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSelfDescriptions(uploadTimerange?: string, statusTimerange?: string, issuers?: Array<string>, validators?: Array<string>, statuses?: Array<ReadSelfDescriptionsStatusesEnum>, ids?: Array<string>, hashes?: Array<string>, withMeta?: boolean, withContent?: boolean, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelfDescriptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSelfDescriptions(uploadTimerange, statusTimerange, issuers, validators, statuses, ids, hashes, withMeta, withContent, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SelfDescriptionsApi.readSelfDescriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Change the lifecycle state of a SelfDescription to revoked.
         * @param {string} selfDescriptionHash Hash of the SelfDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSelfDescription(selfDescriptionHash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelfDescription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSelfDescription(selfDescriptionHash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SelfDescriptionsApi.updateSelfDescription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SelfDescriptionsApi - factory interface
 * @export
 */
export const SelfDescriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SelfDescriptionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new Service-Offering, Participant or Resource SelfDescription to the catalogue
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSelfDescription(body: string, options?: RawAxiosRequestConfig): AxiosPromise<SelfDescription> {
            return localVarFp.addSelfDescription(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Completely delete a self-description
         * @param {string} selfDescriptionHash Hash of the SelfDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSelfDescription(selfDescriptionHash: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSelfDescription(selfDescriptionHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single Self-Description
         * @summary Read a Self-Description by its hash. This returns the content of the self-description.
         * @param {string} selfDescriptionHash Hash of the SelfDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSelfDescriptionByHash(selfDescriptionHash: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.readSelfDescriptionByHash(selfDescriptionHash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of metadata of Self-Descriptions in the Catalogue
         * @param {string} [uploadTimerange] Filter for the time range when the Self-Description was uploaded to the catalogue. The time range has to be specified as start time and end time as ISO8601 timestamp separated by a &#x60;/&#x60;.
         * @param {string} [statusTimerange] Filter for the time range when the status of the Self-Description was last changed in the catalogue. The time range has to be specified as start time and end time as ISO8601 timestamp separated by a &#x60;/&#x60;.
         * @param {Array<string>} [issuers] Filter for the issuer of the Self-Description. This is the unique ID of the Participant that has prepared the Self-Description.
         * @param {Array<string>} [validators] Filter for a validator of the Self-Description. This is the unique ID of the Participant that validated (part of) the Self-Description.
         * @param {Array<ReadSelfDescriptionsStatusesEnum>} [statuses] Filter for the status of the Self-Description.
         * @param {Array<string>} [ids] Filter for a id/credentialSubject of the Self-Description.
         * @param {Array<string>} [hashes] Filter for a hash of the Self-Description.
         * @param {boolean} [withMeta] To add Self-Description Metadata to response or not.
         * @param {boolean} [withContent] To add Self-Description Content to response or not.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSelfDescriptions(uploadTimerange?: string, statusTimerange?: string, issuers?: Array<string>, validators?: Array<string>, statuses?: Array<ReadSelfDescriptionsStatusesEnum>, ids?: Array<string>, hashes?: Array<string>, withMeta?: boolean, withContent?: boolean, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<SelfDescriptions> {
            return localVarFp.readSelfDescriptions(uploadTimerange, statusTimerange, issuers, validators, statuses, ids, hashes, withMeta, withContent, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the lifecycle state of a SelfDescription to revoked.
         * @param {string} selfDescriptionHash Hash of the SelfDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSelfDescription(selfDescriptionHash: string, options?: RawAxiosRequestConfig): AxiosPromise<SelfDescription> {
            return localVarFp.updateSelfDescription(selfDescriptionHash, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SelfDescriptionsApi - object-oriented interface
 * @export
 * @class SelfDescriptionsApi
 * @extends {BaseAPI}
 */
export class SelfDescriptionsApi extends BaseAPI {
    /**
     * 
     * @summary Add a new Service-Offering, Participant or Resource SelfDescription to the catalogue
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SelfDescriptionsApi
     */
    public addSelfDescription(body: string, options?: RawAxiosRequestConfig) {
        return SelfDescriptionsApiFp(this.configuration).addSelfDescription(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Completely delete a self-description
     * @param {string} selfDescriptionHash Hash of the SelfDescription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SelfDescriptionsApi
     */
    public deleteSelfDescription(selfDescriptionHash: string, options?: RawAxiosRequestConfig) {
        return SelfDescriptionsApiFp(this.configuration).deleteSelfDescription(selfDescriptionHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single Self-Description
     * @summary Read a Self-Description by its hash. This returns the content of the self-description.
     * @param {string} selfDescriptionHash Hash of the SelfDescription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SelfDescriptionsApi
     */
    public readSelfDescriptionByHash(selfDescriptionHash: string, options?: RawAxiosRequestConfig) {
        return SelfDescriptionsApiFp(this.configuration).readSelfDescriptionByHash(selfDescriptionHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of metadata of Self-Descriptions in the Catalogue
     * @param {string} [uploadTimerange] Filter for the time range when the Self-Description was uploaded to the catalogue. The time range has to be specified as start time and end time as ISO8601 timestamp separated by a &#x60;/&#x60;.
     * @param {string} [statusTimerange] Filter for the time range when the status of the Self-Description was last changed in the catalogue. The time range has to be specified as start time and end time as ISO8601 timestamp separated by a &#x60;/&#x60;.
     * @param {Array<string>} [issuers] Filter for the issuer of the Self-Description. This is the unique ID of the Participant that has prepared the Self-Description.
     * @param {Array<string>} [validators] Filter for a validator of the Self-Description. This is the unique ID of the Participant that validated (part of) the Self-Description.
     * @param {Array<ReadSelfDescriptionsStatusesEnum>} [statuses] Filter for the status of the Self-Description.
     * @param {Array<string>} [ids] Filter for a id/credentialSubject of the Self-Description.
     * @param {Array<string>} [hashes] Filter for a hash of the Self-Description.
     * @param {boolean} [withMeta] To add Self-Description Metadata to response or not.
     * @param {boolean} [withContent] To add Self-Description Content to response or not.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SelfDescriptionsApi
     */
    public readSelfDescriptions(uploadTimerange?: string, statusTimerange?: string, issuers?: Array<string>, validators?: Array<string>, statuses?: Array<ReadSelfDescriptionsStatusesEnum>, ids?: Array<string>, hashes?: Array<string>, withMeta?: boolean, withContent?: boolean, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return SelfDescriptionsApiFp(this.configuration).readSelfDescriptions(uploadTimerange, statusTimerange, issuers, validators, statuses, ids, hashes, withMeta, withContent, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the lifecycle state of a SelfDescription to revoked.
     * @param {string} selfDescriptionHash Hash of the SelfDescription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SelfDescriptionsApi
     */
    public updateSelfDescription(selfDescriptionHash: string, options?: RawAxiosRequestConfig) {
        return SelfDescriptionsApiFp(this.configuration).updateSelfDescription(selfDescriptionHash, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ReadSelfDescriptionsStatusesEnum = {
    Active: 'active',
    Eol: 'eol',
    Deprecated: 'deprecated',
    Revoked: 'revoked'
} as const;
export type ReadSelfDescriptionsStatusesEnum = typeof ReadSelfDescriptionsStatusesEnum[keyof typeof ReadSelfDescriptionsStatusesEnum];


/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSession: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutCurrentSession: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentSession(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentSession(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.getCurrentSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutCurrentSession(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutCurrentSession(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.logoutCurrentSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentSession(options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.getCurrentSession(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutCurrentSession(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logoutCurrentSession(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getCurrentSession(options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).getCurrentSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public logoutCurrentSession(options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).logoutCurrentSession(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a new user to the associated participant in the catalogue
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser: async (user?: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the user profile
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get roles of the user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRoles', 'userId', userId)
            const localVarPath = `/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the registered users
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the user profile
         * @param {string} userId 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update roles of the user
         * @param {string} userId 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoles: async (userId: string, requestBody?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserRoles', 'userId', userId)
            const localVarPath = `/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register a new user to the associated participant in the catalogue
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUser(user?: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUser(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.addUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the user profile
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get roles of the user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoles(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoles(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the registered users
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfiles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the user profile
         * @param {string} userId 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update roles of the user
         * @param {string} userId 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRoles(userId: string, requestBody?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRoles(userId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Register a new user to the associated participant in the catalogue
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(user?: User, options?: RawAxiosRequestConfig): AxiosPromise<UserProfile> {
            return localVarFp.addUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserProfile> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the user profile
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserProfile> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get roles of the user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getUserRoles(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the registered users
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserProfiles> {
            return localVarFp.getUsers(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the user profile
         * @param {string} userId 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, user: User, options?: RawAxiosRequestConfig): AxiosPromise<UserProfile> {
            return localVarFp.updateUser(userId, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update roles of the user
         * @param {string} userId 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoles(userId: string, requestBody?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<UserProfile> {
            return localVarFp.updateUserRoles(userId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Register a new user to the associated participant in the catalogue
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUser(user?: User, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).addUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the user profile
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get roles of the user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserRoles(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserRoles(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the registered users
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {number} [limit] The number of items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the user profile
     * @param {string} userId 
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(userId: string, user: User, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(userId, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update roles of the user
     * @param {string} userId 
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserRoles(userId: string, requestBody?: Array<string>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserRoles(userId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VerificationApi - axios parameter creator
 * @export
 */
export const VerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send a JSON-LD document to verify with the information from the Catalogue
         * @param {boolean} [verifySemantics] To verify SD semantics or not
         * @param {boolean} [verifySchema] To verify SD agains schema or not
         * @param {boolean} [verifyVPSignature] To verify VP signature or not
         * @param {boolean} [verifyVCSignature] To verify VC signature or not
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify: async (verifySemantics?: boolean, verifySchema?: boolean, verifyVPSignature?: boolean, verifyVCSignature?: boolean, body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (verifySemantics !== undefined) {
                localVarQueryParameter['verifySemantics'] = verifySemantics;
            }

            if (verifySchema !== undefined) {
                localVarQueryParameter['verifySchema'] = verifySchema;
            }

            if (verifyVPSignature !== undefined) {
                localVarQueryParameter['verifyVPSignature'] = verifyVPSignature;
            }

            if (verifyVCSignature !== undefined) {
                localVarQueryParameter['verifyVCSignature'] = verifyVCSignature;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Show a HTML page to verify (portions of) a signed Self-Description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyPage: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerificationApi - functional programming interface
 * @export
 */
export const VerificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Send a JSON-LD document to verify with the information from the Catalogue
         * @param {boolean} [verifySemantics] To verify SD semantics or not
         * @param {boolean} [verifySchema] To verify SD agains schema or not
         * @param {boolean} [verifyVPSignature] To verify VP signature or not
         * @param {boolean} [verifyVCSignature] To verify VC signature or not
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify(verifySemantics?: boolean, verifySchema?: boolean, verifyVPSignature?: boolean, verifyVCSignature?: boolean, body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify(verifySemantics, verifySchema, verifyVPSignature, verifyVCSignature, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerificationApi.verify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Show a HTML page to verify (portions of) a signed Self-Description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyPage(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyPage(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerificationApi.verifyPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VerificationApi - factory interface
 * @export
 */
export const VerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerificationApiFp(configuration)
    return {
        /**
         * 
         * @summary Send a JSON-LD document to verify with the information from the Catalogue
         * @param {boolean} [verifySemantics] To verify SD semantics or not
         * @param {boolean} [verifySchema] To verify SD agains schema or not
         * @param {boolean} [verifyVPSignature] To verify VP signature or not
         * @param {boolean} [verifyVCSignature] To verify VC signature or not
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify(verifySemantics?: boolean, verifySchema?: boolean, verifyVPSignature?: boolean, verifyVCSignature?: boolean, body?: string, options?: RawAxiosRequestConfig): AxiosPromise<VerificationResult> {
            return localVarFp.verify(verifySemantics, verifySchema, verifyVPSignature, verifyVCSignature, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Show a HTML page to verify (portions of) a signed Self-Description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyPage(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.verifyPage(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VerificationApi - object-oriented interface
 * @export
 * @class VerificationApi
 * @extends {BaseAPI}
 */
export class VerificationApi extends BaseAPI {
    /**
     * 
     * @summary Send a JSON-LD document to verify with the information from the Catalogue
     * @param {boolean} [verifySemantics] To verify SD semantics or not
     * @param {boolean} [verifySchema] To verify SD agains schema or not
     * @param {boolean} [verifyVPSignature] To verify VP signature or not
     * @param {boolean} [verifyVCSignature] To verify VC signature or not
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public verify(verifySemantics?: boolean, verifySchema?: boolean, verifyVPSignature?: boolean, verifyVCSignature?: boolean, body?: string, options?: RawAxiosRequestConfig) {
        return VerificationApiFp(this.configuration).verify(verifySemantics, verifySchema, verifyVPSignature, verifyVCSignature, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Show a HTML page to verify (portions of) a signed Self-Description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public verifyPage(options?: RawAxiosRequestConfig) {
        return VerificationApiFp(this.configuration).verifyPage(options).then((request) => request(this.axios, this.basePath));
    }
}



